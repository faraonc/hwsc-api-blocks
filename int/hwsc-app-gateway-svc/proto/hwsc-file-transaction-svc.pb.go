// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hwsc-file-transaction-svc.proto

package hwsc

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FileTransactionRequest struct {
	Identification       *Identification `protobuf:"bytes,1,opt,name=identification,proto3" json:"identification,omitempty"`
	Message              string          `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Name                 string          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Uuid                 string          `protobuf:"bytes,4,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Urls                 []string        `protobuf:"bytes,5,rep,name=urls,proto3" json:"urls,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FileTransactionRequest) Reset()         { *m = FileTransactionRequest{} }
func (m *FileTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*FileTransactionRequest) ProtoMessage()    {}
func (*FileTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ca740a3caeb1644, []int{0}
}

func (m *FileTransactionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileTransactionRequest.Unmarshal(m, b)
}
func (m *FileTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileTransactionRequest.Marshal(b, m, deterministic)
}
func (m *FileTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransactionRequest.Merge(m, src)
}
func (m *FileTransactionRequest) XXX_Size() int {
	return xxx_messageInfo_FileTransactionRequest.Size(m)
}
func (m *FileTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransactionRequest proto.InternalMessageInfo

func (m *FileTransactionRequest) GetIdentification() *Identification {
	if m != nil {
		return m.Identification
	}
	return nil
}

func (m *FileTransactionRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *FileTransactionRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileTransactionRequest) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *FileTransactionRequest) GetUrls() []string {
	if m != nil {
		return m.Urls
	}
	return nil
}

type FileTransactionResponse struct {
	// Types that are valid to be assigned to Status:
	//	*FileTransactionResponse_Code
	Status               isFileTransactionResponse_Status `protobuf_oneof:"status"`
	Message              string                           `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Url                  string                           `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *FileTransactionResponse) Reset()         { *m = FileTransactionResponse{} }
func (m *FileTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*FileTransactionResponse) ProtoMessage()    {}
func (*FileTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ca740a3caeb1644, []int{1}
}

func (m *FileTransactionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileTransactionResponse.Unmarshal(m, b)
}
func (m *FileTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileTransactionResponse.Marshal(b, m, deterministic)
}
func (m *FileTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransactionResponse.Merge(m, src)
}
func (m *FileTransactionResponse) XXX_Size() int {
	return xxx_messageInfo_FileTransactionResponse.Size(m)
}
func (m *FileTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransactionResponse proto.InternalMessageInfo

type isFileTransactionResponse_Status interface {
	isFileTransactionResponse_Status()
}

type FileTransactionResponse_Code struct {
	Code uint32 `protobuf:"varint,1,opt,name=code,proto3,oneof"`
}

func (*FileTransactionResponse_Code) isFileTransactionResponse_Status() {}

func (m *FileTransactionResponse) GetStatus() isFileTransactionResponse_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *FileTransactionResponse) GetCode() uint32 {
	if x, ok := m.GetStatus().(*FileTransactionResponse_Code); ok {
		return x.Code
	}
	return 0
}

func (m *FileTransactionResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *FileTransactionResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FileTransactionResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FileTransactionResponse_OneofMarshaler, _FileTransactionResponse_OneofUnmarshaler, _FileTransactionResponse_OneofSizer, []interface{}{
		(*FileTransactionResponse_Code)(nil),
	}
}

func _FileTransactionResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FileTransactionResponse)
	// status
	switch x := m.Status.(type) {
	case *FileTransactionResponse_Code:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Code))
	case nil:
	default:
		return fmt.Errorf("FileTransactionResponse.Status has unexpected type %T", x)
	}
	return nil
}

func _FileTransactionResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FileTransactionResponse)
	switch tag {
	case 1: // status.code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Status = &FileTransactionResponse_Code{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _FileTransactionResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FileTransactionResponse)
	// status
	switch x := m.Status.(type) {
	case *FileTransactionResponse_Code:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Code))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Chunk struct {
	// Types that are valid to be assigned to TestOneof:
	//	*Chunk_Identification
	//	*Chunk_Buffer
	//	*Chunk_Length
	//	*Chunk_FileName
	//	*Chunk_Uuid
	TestOneof            isChunk_TestOneof `protobuf_oneof:"test_oneof"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}
func (*Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ca740a3caeb1644, []int{2}
}

func (m *Chunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Chunk.Unmarshal(m, b)
}
func (m *Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Chunk.Marshal(b, m, deterministic)
}
func (m *Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chunk.Merge(m, src)
}
func (m *Chunk) XXX_Size() int {
	return xxx_messageInfo_Chunk.Size(m)
}
func (m *Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Chunk proto.InternalMessageInfo

type isChunk_TestOneof interface {
	isChunk_TestOneof()
}

type Chunk_Identification struct {
	Identification *Identification `protobuf:"bytes,1,opt,name=identification,proto3,oneof"`
}

type Chunk_Buffer struct {
	Buffer []byte `protobuf:"bytes,2,opt,name=buffer,proto3,oneof"`
}

type Chunk_Length struct {
	Length int64 `protobuf:"varint,3,opt,name=length,proto3,oneof"`
}

type Chunk_FileName struct {
	FileName string `protobuf:"bytes,4,opt,name=file_name,json=fileName,proto3,oneof"`
}

type Chunk_Uuid struct {
	Uuid string `protobuf:"bytes,5,opt,name=uuid,proto3,oneof"`
}

func (*Chunk_Identification) isChunk_TestOneof() {}

func (*Chunk_Buffer) isChunk_TestOneof() {}

func (*Chunk_Length) isChunk_TestOneof() {}

func (*Chunk_FileName) isChunk_TestOneof() {}

func (*Chunk_Uuid) isChunk_TestOneof() {}

func (m *Chunk) GetTestOneof() isChunk_TestOneof {
	if m != nil {
		return m.TestOneof
	}
	return nil
}

func (m *Chunk) GetIdentification() *Identification {
	if x, ok := m.GetTestOneof().(*Chunk_Identification); ok {
		return x.Identification
	}
	return nil
}

func (m *Chunk) GetBuffer() []byte {
	if x, ok := m.GetTestOneof().(*Chunk_Buffer); ok {
		return x.Buffer
	}
	return nil
}

func (m *Chunk) GetLength() int64 {
	if x, ok := m.GetTestOneof().(*Chunk_Length); ok {
		return x.Length
	}
	return 0
}

func (m *Chunk) GetFileName() string {
	if x, ok := m.GetTestOneof().(*Chunk_FileName); ok {
		return x.FileName
	}
	return ""
}

func (m *Chunk) GetUuid() string {
	if x, ok := m.GetTestOneof().(*Chunk_Uuid); ok {
		return x.Uuid
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Chunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Chunk_OneofMarshaler, _Chunk_OneofUnmarshaler, _Chunk_OneofSizer, []interface{}{
		(*Chunk_Identification)(nil),
		(*Chunk_Buffer)(nil),
		(*Chunk_Length)(nil),
		(*Chunk_FileName)(nil),
		(*Chunk_Uuid)(nil),
	}
}

func _Chunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Chunk)
	// test_oneof
	switch x := m.TestOneof.(type) {
	case *Chunk_Identification:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Identification); err != nil {
			return err
		}
	case *Chunk_Buffer:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Buffer)
	case *Chunk_Length:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Length))
	case *Chunk_FileName:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.FileName)
	case *Chunk_Uuid:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Uuid)
	case nil:
	default:
		return fmt.Errorf("Chunk.TestOneof has unexpected type %T", x)
	}
	return nil
}

func _Chunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Chunk)
	switch tag {
	case 1: // test_oneof.identification
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Identification)
		err := b.DecodeMessage(msg)
		m.TestOneof = &Chunk_Identification{msg}
		return true, err
	case 2: // test_oneof.buffer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.TestOneof = &Chunk_Buffer{x}
		return true, err
	case 3: // test_oneof.length
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TestOneof = &Chunk_Length{int64(x)}
		return true, err
	case 4: // test_oneof.file_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.TestOneof = &Chunk_FileName{x}
		return true, err
	case 5: // test_oneof.uuid
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.TestOneof = &Chunk_Uuid{x}
		return true, err
	default:
		return false, nil
	}
}

func _Chunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Chunk)
	// test_oneof
	switch x := m.TestOneof.(type) {
	case *Chunk_Identification:
		s := proto.Size(x.Identification)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Chunk_Buffer:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Buffer)))
		n += len(x.Buffer)
	case *Chunk_Length:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Length))
	case *Chunk_FileName:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.FileName)))
		n += len(x.FileName)
	case *Chunk_Uuid:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Uuid)))
		n += len(x.Uuid)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*FileTransactionRequest)(nil), "hwscFileTransactionSvc.FileTransactionRequest")
	proto.RegisterType((*FileTransactionResponse)(nil), "hwscFileTransactionSvc.FileTransactionResponse")
	proto.RegisterType((*Chunk)(nil), "hwscFileTransactionSvc.Chunk")
}

func init() { proto.RegisterFile("hwsc-file-transaction-svc.proto", fileDescriptor_0ca740a3caeb1644) }

var fileDescriptor_0ca740a3caeb1644 = []byte{
	// 424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xb5, 0x71, 0x12, 0x9a, 0xa1, 0x40, 0xb5, 0x44, 0xc5, 0xaa, 0x54, 0x11, 0xf9, 0x94, 0x4b,
	0x0c, 0x2a, 0x57, 0xc4, 0xa1, 0x45, 0xc5, 0x5c, 0x38, 0x38, 0xf4, 0xc2, 0xa5, 0x6c, 0xec, 0x71,
	0xbc, 0x62, 0xb3, 0x6b, 0xf6, 0x23, 0x11, 0xff, 0x89, 0xdf, 0xc0, 0x1f, 0xe0, 0x4f, 0xa1, 0x5d,
	0x1b, 0x21, 0x92, 0x10, 0x11, 0x0e, 0xbd, 0xcd, 0xbc, 0xf7, 0x34, 0xf3, 0xfc, 0x66, 0x0d, 0xcf,
	0xea, 0xb5, 0x2e, 0xa6, 0x15, 0xe3, 0x38, 0x35, 0x8a, 0x0a, 0x4d, 0x0b, 0xc3, 0xa4, 0x98, 0xea,
	0x55, 0x91, 0x36, 0x4a, 0x1a, 0x49, 0x4e, 0x9d, 0xe0, 0x9a, 0x71, 0xfc, 0xf0, 0x9b, 0x9e, 0xad,
	0x8a, 0xb3, 0xc7, 0xd4, 0x9a, 0x5a, 0x2a, 0x66, 0xbe, 0xb6, 0xc2, 0xe4, 0x5b, 0x08, 0xa7, 0x1b,
	0xba, 0x1c, 0xbf, 0x58, 0xd4, 0x86, 0xbc, 0x82, 0x47, 0xac, 0x44, 0x61, 0x58, 0xc5, 0x0a, 0xea,
	0x88, 0x38, 0x1c, 0x87, 0x93, 0x07, 0x17, 0xa3, 0xd4, 0x0d, 0x4f, 0xdf, 0xfd, 0xc1, 0xe5, 0x1b,
	0x5a, 0x12, 0xc3, 0xfd, 0x25, 0x6a, 0x4d, 0x17, 0x18, 0xdf, 0x1b, 0x87, 0x93, 0x61, 0xfe, 0xab,
	0x25, 0x04, 0x7a, 0x82, 0x2e, 0x31, 0x8e, 0x3c, 0xec, 0x6b, 0x87, 0x59, 0xcb, 0xca, 0xb8, 0xd7,
	0x62, 0xae, 0xf6, 0x98, 0xe2, 0x3a, 0xee, 0x8f, 0x23, 0x8f, 0x29, 0xae, 0x13, 0x84, 0xa7, 0x5b,
	0x6e, 0x75, 0x23, 0x85, 0x46, 0x32, 0x82, 0x5e, 0x21, 0x4b, 0xf4, 0x26, 0x1f, 0x66, 0x41, 0xee,
	0xbb, 0x3d, 0x36, 0x4e, 0x20, 0xb2, 0x8a, 0x77, 0x2e, 0x5c, 0x79, 0x79, 0x04, 0x03, 0x6d, 0xa8,
	0xb1, 0x3a, 0xf9, 0x1e, 0x42, 0xff, 0xaa, 0xb6, 0xe2, 0x33, 0x79, 0x7d, 0x48, 0x08, 0x59, 0xb0,
	0x23, 0x86, 0xc1, 0xdc, 0x56, 0x15, 0x2a, 0xbf, 0xfe, 0x38, 0x0b, 0xf2, 0xae, 0x77, 0x0c, 0x47,
	0xb1, 0x30, 0xb5, 0xb7, 0x10, 0x39, 0xa6, 0xed, 0xc9, 0x39, 0x0c, 0xdd, 0x69, 0x6f, 0x7d, 0x4a,
	0x3e, 0x91, 0x2c, 0xc8, 0x8f, 0x1c, 0xf4, 0xde, 0x65, 0x35, 0xea, 0xb2, 0xea, 0x77, 0x8c, 0xef,
	0x2e, 0x8f, 0x01, 0x0c, 0x6a, 0x73, 0x2b, 0x05, 0xca, 0xea, 0xe2, 0x47, 0xb4, 0x75, 0xd6, 0x19,
	0xaa, 0x15, 0x2b, 0x90, 0x08, 0x18, 0xbe, 0x45, 0x33, 0xf3, 0x1f, 0x4a, 0xd2, 0x74, 0xf7, 0x43,
	0x49, 0x77, 0xbf, 0x89, 0xb3, 0xe7, 0xff, 0xac, 0x6f, 0xaf, 0x92, 0x04, 0xe4, 0x13, 0xc0, 0x4d,
	0xc3, 0x25, 0x2d, 0x9d, 0x84, 0x9c, 0xff, 0x6d, 0x80, 0x8f, 0xfb, 0x3f, 0xe6, 0x4f, 0x42, 0x52,
	0xc3, 0x93, 0x37, 0x72, 0x2d, 0xdc, 0x8e, 0x8f, 0xac, 0x69, 0xd0, 0x6f, 0x3a, 0xfc, 0xdb, 0xf6,
	0x5b, 0x4b, 0x82, 0x17, 0x21, 0xb1, 0x70, 0x72, 0xa5, 0x90, 0x1a, 0xbc, 0xd1, 0xa8, 0xae, 0x25,
	0x2f, 0x51, 0xdd, 0x41, 0x84, 0xf3, 0x81, 0xff, 0x57, 0x5f, 0xfe, 0x0c, 0x00, 0x00, 0xff, 0xff,
	0x72, 0x61, 0x0a, 0x01, 0xf7, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileTransactionServiceClient is the client API for FileTransactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileTransactionServiceClient interface {
	// Gets status for user
	GetStatus(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error)
	// Upload files to the storage
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileTransactionService_UploadFileClient, error)
	// Download files from the storage
	DownloadZippedFiles(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (FileTransactionService_DownloadZippedFilesClient, error)
	// Create user folder in the sorage
	CreateUserFolder(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error)
}

type fileTransactionServiceClient struct {
	cc *grpc.ClientConn
}

func NewFileTransactionServiceClient(cc *grpc.ClientConn) FileTransactionServiceClient {
	return &fileTransactionServiceClient{cc}
}

func (c *fileTransactionServiceClient) GetStatus(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error) {
	out := new(FileTransactionResponse)
	err := c.cc.Invoke(ctx, "/hwscFileTransactionSvc.FileTransactionService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransactionServiceClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileTransactionService_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileTransactionService_serviceDesc.Streams[0], "/hwscFileTransactionSvc.FileTransactionService/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransactionServiceUploadFileClient{stream}
	return x, nil
}

type FileTransactionService_UploadFileClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*FileTransactionResponse, error)
	grpc.ClientStream
}

type fileTransactionServiceUploadFileClient struct {
	grpc.ClientStream
}

func (x *fileTransactionServiceUploadFileClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileTransactionServiceUploadFileClient) CloseAndRecv() (*FileTransactionResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(FileTransactionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileTransactionServiceClient) DownloadZippedFiles(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (FileTransactionService_DownloadZippedFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileTransactionService_serviceDesc.Streams[1], "/hwscFileTransactionSvc.FileTransactionService/DownloadZippedFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransactionServiceDownloadZippedFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileTransactionService_DownloadZippedFilesClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type fileTransactionServiceDownloadZippedFilesClient struct {
	grpc.ClientStream
}

func (x *fileTransactionServiceDownloadZippedFilesClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileTransactionServiceClient) CreateUserFolder(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error) {
	out := new(FileTransactionResponse)
	err := c.cc.Invoke(ctx, "/hwscFileTransactionSvc.FileTransactionService/CreateUserFolder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileTransactionServiceServer is the server API for FileTransactionService service.
type FileTransactionServiceServer interface {
	// Gets status for user
	GetStatus(context.Context, *FileTransactionRequest) (*FileTransactionResponse, error)
	// Upload files to the storage
	UploadFile(FileTransactionService_UploadFileServer) error
	// Download files from the storage
	DownloadZippedFiles(*FileTransactionRequest, FileTransactionService_DownloadZippedFilesServer) error
	// Create user folder in the sorage
	CreateUserFolder(context.Context, *FileTransactionRequest) (*FileTransactionResponse, error)
}

func RegisterFileTransactionServiceServer(s *grpc.Server, srv FileTransactionServiceServer) {
	s.RegisterService(&_FileTransactionService_serviceDesc, srv)
}

func _FileTransactionService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileTransactionServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hwscFileTransactionSvc.FileTransactionService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileTransactionServiceServer).GetStatus(ctx, req.(*FileTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileTransactionService_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileTransactionServiceServer).UploadFile(&fileTransactionServiceUploadFileServer{stream})
}

type FileTransactionService_UploadFileServer interface {
	SendAndClose(*FileTransactionResponse) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type fileTransactionServiceUploadFileServer struct {
	grpc.ServerStream
}

func (x *fileTransactionServiceUploadFileServer) SendAndClose(m *FileTransactionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileTransactionServiceUploadFileServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileTransactionService_DownloadZippedFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileTransactionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileTransactionServiceServer).DownloadZippedFiles(m, &fileTransactionServiceDownloadZippedFilesServer{stream})
}

type FileTransactionService_DownloadZippedFilesServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type fileTransactionServiceDownloadZippedFilesServer struct {
	grpc.ServerStream
}

func (x *fileTransactionServiceDownloadZippedFilesServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _FileTransactionService_CreateUserFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileTransactionServiceServer).CreateUserFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hwscFileTransactionSvc.FileTransactionService/CreateUserFolder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileTransactionServiceServer).CreateUserFolder(ctx, req.(*FileTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileTransactionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hwscFileTransactionSvc.FileTransactionService",
	HandlerType: (*FileTransactionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _FileTransactionService_GetStatus_Handler,
		},
		{
			MethodName: "CreateUserFolder",
			Handler:    _FileTransactionService_CreateUserFolder_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _FileTransactionService_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadZippedFiles",
			Handler:       _FileTransactionService_DownloadZippedFiles_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "hwsc-file-transaction-svc.proto",
}
